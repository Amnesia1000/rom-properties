/***************************************************************************
 * ROM Properties Page shell extension. (libromdata)                       *
 * NintendoDS.hpp: Nintendo DS(i) ROM reader. (ROM operations)             *
 *                                                                         *
 * Copyright (c) 2016-2020 by David Korth.                                 *
 * SPDX-License-Identifier: GPL-2.0-or-later                               *
 ***************************************************************************/

#include "stdafx.h"

#include "NintendoDS.hpp"
#include "NintendoDS_p.hpp"

// librpbase
using LibRpBase::RomData;

// C++ STL classes.
using std::vector;

namespace LibRomData {

/** NintendoDSPrivate **/

/**
 * Is the ROM trimmed?
 * @return True if trimmed; false if not trimmed.
 */
bool NintendoDSPrivate::isRomTrimmed(void) const
{
	// If the ROM size is larger than the "used" size in the
	// ROM header, then it's not trimmed.
	// TODO: What if the ROM size is an exact power of two?
	const uint32_t total_used_rom_size =
		likely(romType < RomType::DSi_Enhanced)
		? le32_to_cpu(romHeader.total_used_rom_size)
		: le32_to_cpu(romHeader.dsi.total_used_rom_size);

	return !(total_used_rom_size < this->romSize);
}

/**
 * Check the NDS security data.
 *
 * $1000-$3FFF is normally unreadable on hardware, so this
 * area is usually blank in dumped ROMs. However, this area
 * normally has precomputed Blowfish tables and other data,
 * which are used as part of the NDS security system.
 * DSiWare and Wii U VC SRLs, as well as SRLs generated by
 * the DS SDK, will have actual data here.
 *
 * @return NDS security data flags.
 */
uint32_t NintendoDSPrivate::checkNDSSecurityData(void)
{
	// TODO: Verify the entire area. (Not sure if we can calculate the
	// Random data correctly...)
	uint32_t ret = 0;
	if (!file || !file->isOpen()) {
		// File was closed...
		return ret;
	}

	uint32_t security_data[0x3000/4];
	size_t size = file->seekAndRead(0x1000, security_data, sizeof(security_data));
	if (size != sizeof(security_data)) {
		// Seek and/or read error.
		return 0;
	}

	// Check the S-Box and Blowfish tables for non-zero data.
	// S-Box: 0x1600
	// Blowfish: 0x1C00
	if (security_data[0x0600/4] != 0 && security_data[0x0C00/4] != 0) {
		ret |= NDS_SECDATA_BLOWFISH;
	}

	// Check the static area.
	if (security_data[0x2000/4] == be32_to_cpu(0xFF00FF00) &&
	    security_data[0x2004/4] == be32_to_cpu(0xAA55AA55) &&
	    security_data[0x2008/4] == be32_to_cpu(0x08090A0B) &&
	    security_data[0x200C/4] == be32_to_cpu(0x0C0D0E0F) &&
	    security_data[0x2200/4] == be32_to_cpu(0xFFFEFDFC) &&
	    security_data[0x2204/4] == be32_to_cpu(0xFBFAF9F8) &&
	    security_data[0x2400/4] == be32_to_cpu(0x00000000) &&
	    security_data[0x2600/4] == be32_to_cpu(0xFFFFFFFF) &&
	    security_data[0x2800/4] == be32_to_cpu(0x0F0F0F0F) &&
	    security_data[0x2A00/4] == be32_to_cpu(0xF0F0F0F0) &&
	    security_data[0x2C00/4] == be32_to_cpu(0x55555555) &&
	    security_data[0x2E00/4] == be32_to_cpu(0xAAAAAAAA))
	{
		// Static area appears to be valid.
		ret |= NDS_SECDATA_STATIC;
	}

	// Check for random values at other areas.
	if (security_data[0x0000/4] != 0 ||
	    security_data[0x0700/4] != 0 ||
	    security_data[0x1C00/4] != 0)
	{
		// Non-zero value in one of these areas.
		// Random data is present.
		ret |= NDS_SECDATA_RANDOM;
	}

	return ret;
}

/**
 * Check the NDS Secure Area type.
 * @return Secure area type.
 */
NintendoDSPrivate::NDS_SecureArea NintendoDSPrivate::checkNDSSecureArea(void)
{
	if (!file || !file->isOpen()) {
		// File was closed...
		return NDS_SECAREA_UNKNOWN;
	}

	// Read the start of the Secure Area.
	// NOTE: We only need to check the first two DWORDs, but
	// we're reading the first four because CIAReader only
	// supports multiples of 16 bytes right now.
	uint32_t secure_area[4];
	size_t size = file->seekAndRead(0x4000, secure_area, sizeof(secure_area));
	if (size != sizeof(secure_area)) {
		// Seek and/or read error.
		return NDS_SECAREA_UNKNOWN;
	}

	// Reference: https://github.com/devkitPro/ndstool/blob/master/source/header.cpp#L39

	NDS_SecureArea ret;
	//bool needs_encryption = false;	// TODO
	if (le32_to_cpu(romHeader.arm9.rom_offset) < 0x4000) {
		// ARM9 secure area is not present.
		// This is only valid for homebrew.
		ret = NDS_SECAREA_HOMEBREW;
	} else if (secure_area[0] == cpu_to_le32(0x00000000) && secure_area[1] == cpu_to_le32(0x00000000)) {
		// Secure area is empty. (DS Download Play)
		ret = NDS_SECAREA_MULTIBOOT;
	} else if (secure_area[0] == cpu_to_le32(0xE7FFDEFF) && secure_area[1] == cpu_to_le32(0xE7FFDEFF)) {
		// Secure area is decrypted.
		// Probably dumped using wooddumper or Decrypt9WIP.
		ret = NDS_SECAREA_DECRYPTED;
		//needs_encryption = true;	// CRC requires encryption.
	} else {
		// Secure area is encrypted.
		ret = NDS_SECAREA_ENCRYPTED;
	}

	// TODO: Verify the CRC?
	// For decrypted ROMs, this requires re-encrypting the secure area.
	return ret;
}

/** NintendoDS **/

/**
 * Get the list of operations that can be performed on this ROM.
 * Internal function; called by RomData::romOps().
 * @return List of operations.
 */
vector<RomData::RomOps> NintendoDS::romOps_int(void) const
{
	// Determine if the ROM is trimmed and/or encrypted.
	// TODO: Make this non-static.
	vector<RomOps> ops;
	ops.reserve(2);

	RP_D(NintendoDS);
	if (d->romSize > 0) {
		const char *const s_trim = d->isRomTrimmed()
			? C_("NintendoDS|RomOps", "Untrim ROM")
			: C_("NintendoDS|RomOps", "Trim ROM");
		ops.emplace_back(RomOps(s_trim, 0));
	}

	switch (d->secArea) {
		case NintendoDSPrivate::NDS_SECAREA_DECRYPTED:
			ops.emplace_back(RomOps(C_("NintendoDS|RomOps", "Encrypt ROM"), 0));
			break;
		case NintendoDSPrivate::NDS_SECAREA_ENCRYPTED:
			ops.emplace_back(RomOps(C_("NintendoDS|RomOps", "Decrypt ROM"), 0));
			break;
		default:
			break;
	}

	return ops;
}

/**
 * Perform a ROM operation.
 * Internal function; called by RomData::doRomOp().
 * @param id Operation index.
 * @return 0 on success; negative POSIX error code on error.
 */
int NintendoDS::doRomOp_int(int id)
{
	RP_D(NintendoDS);
	int ret = 0;

	switch (id) {
		case 0:
			// Trim/untrim ROM.
			// Trim = reduce ROM to minimum size as indicated by header.
			// Untrim = expand to power of 2 size, filled with 0xFF.
			break;

		case 1:
			// Encrypt/decrypt ROM.
			break;
	}

	return ret;
}

}
